<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on یادداشتهای بیت نیمسوز</title>
    <link>http://fzero.rubi.gd/categories/go/</link>
    <description>Recent content in Go on یادداشتهای بیت نیمسوز</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fa-ir</language>
    <lastBuildDate>Sun, 01 May 2016 08:01:37 +0430</lastBuildDate>
    <atom:link href="http://fzero.rubi.gd/categories/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>تزریق! نسخه به باینری وقت کامپایل #Golang</title>
      <link>http://fzero.rubi.gd/post/go/inject-go-version/</link>
      <pubDate>Sun, 01 May 2016 08:01:37 +0430</pubDate>
      
      <guid>http://fzero.rubi.gd/post/go/inject-go-version/</guid>
      <description>&lt;p&gt;بدنیست همیشه یه اطلاعاتی از نسخه برنامه تو دل خودش باشه. مدتهاست که من از Make برای کامپایل برنامه استفاده میکنم، و قبلترها، قبل از اینکه کامپایل کنم برنامه رو، یک فایل میساختم (به صورت اتوماتیک) مثلا با این محتوا :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main 
// this file is autogenerated
var (
	// Commit hash 
	hash  = &amp;quot;a5df371b88bc3f875f49a3b7e19b55c88cd31487&amp;quot;
	short = &amp;quot;a5df371&amp;quot;
	// commit date
	date  = &amp;quot;2016-04-30 11:21:46 +0430 +0430&amp;quot;
	// build date 
	build = &amp;quot;2016-04-30 11:21:46 +0430 +0430&amp;quot;
	// commit count
	count = &amp;quot;42&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;بعد قبل هر کامپایل این فایل مجددا ساخته میشه و متغیرهاش آپدیت میشن. خوبه، ولی نه به اندازه کافی. این فایل باید ignore بشه تو ورژن کنترل، کسی از کامند مناسب استفاده نکنه ساخته نمیشه و الی آخر. این شد که افتادم دنبال راه حل بهتر.&lt;/p&gt;

&lt;p&gt;بعد از اینکه کامپایلر کارش تموم میشه، و فایل های میانی ساخته میشن، لینکر اونها رو به هم لینک میکنه و فایل نهایی ساخته میشن. تو این مرحله، تازه رفرنسها مشخص میشن، و ارتباطها پیدا میشن و در صورتی که ارتباطی پیدا نشه خطا گرفته میشه، البته برای گو، یه لول هم قبلتر اتفاق میفته، (بر خلاف سی) ولی خوب، کلا قضیه اینه که اگه بخوای یه متغییر رو عوض کنی، بعد از کامپایل میشه.&lt;/p&gt;

&lt;p&gt;برای اینکار گو سوییچ ‍&lt;code&gt;-X&lt;/code&gt; رو معرفی کرده. خیلی ساده، &lt;code&gt;-ldflags &amp;quot;-X pkg.variable=value‍&lt;/code&gt; اینجوری میتونم به لینکر بگم که متغییری به اسم &lt;code&gt;variable&lt;/code&gt; توی پکیجی به اسم &lt;code&gt;pkg&lt;/code&gt; باید مقدارش برابر باشه با &lt;code&gt;value&lt;/code&gt; . با این روش فقط میشه متغییر های رشته ای (string) رو وارد برنامه کرد و تایپ نمیشناسه.&lt;/p&gt;

&lt;p&gt;مثلا این برنامه رو در نظر بگیرید :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

var variable string

func main() {
	fmt.Println(variable)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;کامپایلش کنید طبیعیه که خروجی یه خط خالیه. ولی حالا اینجوری کامپایلش کنید :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go build -ldflags &amp;quot;-X main.variable=value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;و دیگه خروجی خالی نیست. اگه از &lt;a href=&#34;https://getgb.io/&#34;&gt;gb&lt;/a&gt; استفاده میکنید (من استفاده میکنم :) ) اونهم این فلگ رو میشناسه. مثلا من این خطوط رو اول Makefile گذاشتم :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LONGHASH=$(shell git log -n1 --pretty=&amp;quot;format:%H&amp;quot; | cat)
export SHORTHASH=$(shell git log -n1 --pretty=&amp;quot;format:%h&amp;quot;| cat)
export COMMITDATE=$(shell git log -n1 --pretty=&amp;quot;format:%cd&amp;quot;| sed -e &amp;quot;s/ /-/g&amp;quot;)
export COMMITCOUNT=$(shell git rev-list HEAD --count| cat)
export BUILDDATE=$(shell date| sed -e &amp;quot;s/ /-/g&amp;quot;)
export FLAGS=&amp;quot;-X shared/config.hash=$(LONGHASH) -X shared/config.short=$(SHORTHASH) -X shared/config.date=$(COMMITDATE) -X shared/config.count=$(COMMITCOUNT) -X shared/config.build=$(BUILDDATE)&amp;quot;
export LDARG=-ldflags $(FLAGS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;و هر وقت تو Makefile بخوام چیزی رو کامپایل کنم اینجوری میشه :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(BIN)/gb build $(LDARG)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;تو پکیج &lt;code&gt;shared/config&lt;/code&gt; هم چنین چیزی دارم :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The following variables are injected at compile time, do not edit
var (
	hash  string
	short string
	date  string
	build string
	count string
)

func init() {
	Config.Count, _ = strconv.ParseInt(count, 10, 64)
	Config.Date, _ = time.Parse(&amp;quot;Mon-Jan-02-15:04:05-2006--0700&amp;quot;, date)
	Config.Hash = hash
	Config.Short = short
	Config.BuildDate, _ = time.Parse(&amp;quot;Mon-Jan-02-15:04:05-MST-2006&amp;quot;, build)

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ndash; متوجه شدید این حضرات مکافات، تو کامپایلر go به جای دو تا دش از یه دش استفاده میکنن؟ این یکی از مشکلاتیه که من باهاشون دارم! لامصبا رفتن استاندارد مزخرف &lt;a href=&#34;https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs&#34;&gt;plan9&lt;/a&gt; رو اینجا استفاده کردن به جای &lt;a href=&#34;https://en.wikipedia.org/wiki/Getopt&#34;&gt;getopt&lt;/a&gt; :/&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go web server on port 80</title>
      <link>http://fzero.rubi.gd/post/go/go-web-server/</link>
      <pubDate>Thu, 14 Apr 2016 17:00:34 +0430</pubDate>
      
      <guid>http://fzero.rubi.gd/post/go/go-web-server/</guid>
      <description>&lt;p&gt;Golang یک کتابخانه عالی &lt;a href=&#34;https://golang.org/pkg/net/http/&#34;&gt;http&lt;/a&gt; داره که کلی قابلیت بهت میده. مثلا &lt;a href=&#34;http://http2.golang.org/&#34;&gt;http2&lt;/a&gt; و  قابلیت ساپورت رنج روی فایل برای دانلود که تقریبا به &lt;a href=&#34;https://golang.org/pkg/net/http/#ServeContent&#34;&gt;سادگی آب خوردن&lt;/a&gt; پیاده میشه.
من معمولا یه وب سرور میذاشتم سر راهش. یعنی پروکسیش میکردم. مثلا &lt;a href=&#34;https://www.nginx.com/&#34;&gt;nginx&lt;/a&gt; و هنوزم خیلی وقتا اینکار رو میکنم.
منتها یه وقتایی هست که کلا نمیخوای درگیر وب سرور خارجی بشی. دلیلش هر چی هست :)‌ و میخوای از سرور خود Golang استفاده کنی. این کاملا با اون چیزی که توی پایتون و روبی و PHP به عنوان وب سرور به خوردمون دادن متفاوته. این یک سرور آماده برای کاره نه یک وب سرور برای محیط دولوپمنت.&lt;/p&gt;

&lt;p&gt;خوب اوکی، وب سرور آماده کاره، کد من چی؟آیا عاقلانست کدم رو با دسترسی روت اجرا کنم؟
چرا با روت؟ چون میخوام رو پورت ۸۰ یا ۴۴۳ گوش وایسه وب سرورم، و طبق استاندارد، فقط برنامه های اجرا شده با دسترسی روت میتونن روی پورتهای پایینتر از ۱۰۲۴ گوش وایسن.&lt;/p&gt;

&lt;p&gt;خوب یه کم نا امید کنندست. من هرگز همچین کاری نمیکنم. میشه انداختش توی داکر و امنیتش رو تا حدی تضمین کرد . دست کم اینه که اگه تو کد من زدم &lt;code&gt;rm -rf&lt;/code&gt; همه چی نمیترکه.
ولی راه ساده ترش ایه که به این فایل به خصوص اجازه بدیم رو پورتهای کمتر از ۱۰۲۴ هم گوش وایسه :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# setcap cap_net_bind_service=+ep /path/to/executable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;طبیعیه که # به معنی اینه که این دستور با دسترسی روت اجرا میشه. بعد از این دستور این برنامه میتونه روی پورتهای پایینتر هم گوش وایسه.&lt;/p&gt;

&lt;p&gt;برای اینکه بفهمید چه اتفاقی میفته، اول &lt;code&gt;man setcap&lt;/code&gt; رو ببینید و برای لیست &lt;code&gt;capabilities&lt;/code&gt; هم طبیعتا &lt;code&gt;man capabilities&lt;/code&gt; رو.&lt;/p&gt;

&lt;p&gt;&amp;ndash; همین.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>اولین کامیتهای پروژه Go</title>
      <link>http://fzero.rubi.gd/post/go/go-first-commit/</link>
      <pubDate>Sat, 02 Apr 2016 23:31:08 +0430</pubDate>
      
      <guid>http://fzero.rubi.gd/post/go/go-first-commit/</guid>
      <description>&lt;p&gt;شوخ طبعی دولوپرها همیشه جالب بوده برام، چون اصولا ندارن و چیزهایی که براشون شوخی حساب میشه رو کسی جز خودشون براش بامزه حساب نمیشه.&lt;/p&gt;

&lt;p&gt;این شوخی تیم گو بوده که اولین کامیتهای گو رو اینطوری رقم زده :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://fzero.rubi.gd/images/go-first/gh.png&#34; alt=&#34;the very first commits of go project&#34; /&gt;
&lt;a href=&#34;https://github.com/golang/go/commit/7d7c6a97f815e9279d08cfaea7d5efb5e90695a8&#34;&gt;لینک اولین کامیت&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;برای اونها که ممکنه شوخی رو نگرفته باشن، تاریخ و Author اون چهار تا کامیت اول رو ببینید. &lt;a href=&#34;https://en.wikipedia.org/wiki/Brian_Kernighan&#34;&gt;Brian Kernighan&lt;/a&gt;، کسی که اولین &lt;a href=&#34;https://en.wikipedia.org/wiki/%22Hello,_World!%22_program&#34;&gt;Hello World&lt;/a&gt; شناخته شده رو تو کتابش داره، تاریخ هم که خیلی قدیمیه، برمیگرده به قبل از زبان C حتی.&lt;/p&gt;

&lt;p&gt;از دید من این یعنی که ما سعی داریم فلک را سقف بشکافیم و طرحی نو در اندازیم، و برای همین تمام تجربه های دیگه رو گذاشتیم کنار و از C رسیدیم به Go (هر چند که نذاشتن و خیلی زبانهای دیگه تو شکل گیری Go نقش داشتن.)&lt;/p&gt;

&lt;!-- روز خوبی نبود امروز، درگیریهای توی شرکت، دعواهای توییتری :))  --&gt;
</description>
    </item>
    
    <item>
      <title>گور بدون مرده - ssh-honeypot</title>
      <link>http://fzero.rubi.gd/post/ssh-honey-pot/</link>
      <pubDate>Fri, 12 Dec 2014 15:55:44 +0330</pubDate>
      
      <guid>http://fzero.rubi.gd/post/ssh-honey-pot/</guid>
      <description>&lt;p&gt;یکی از تکنیکهای امنیتی که بهش هانی‌پات یا همون کندوی عسل هم میگن، اینه که یه سرویس جعلی ایجاد کنی و بعد اونو به جای سرویس اصلی بذاری. این سرویس نباید خیلی سنگین باشه، معمولا پشتش هیچی نیست و هر کاری هم که صورت بگیره آخرش اتفاق خاصی قرار نیست بیفته. اون کسی که قصد نفوذ به سیستم رو داره گیر این تله میفته و به جای اینکه واقعا برسه به سرویس اصلی با یه نسخه احمقانه سرش گرم میشه:)&lt;br /&gt;
این سرویس جعلی باید کاملا مشابه سرویس اصلی باشه. حتی ایده‌آلش اینه که به کاربر اکسس هم بده و بندازتش تو یه محیط محدود مثل موش آزمایشگاهی :)))&lt;/p&gt;

&lt;p&gt;معادلی که ما تو فارسی میتونیم ازش استفاده کنیم، گور بدون مرده‌است. همون ضرب‌المثلی که میگه این گوری که تو روش گریه میکنی مرده توش نیست. منم دیشب برای اینکه یه تجربه‌ای داشته باشم با golang دست به کار شدم و یدونه خیلی سادشو استارت زدم.&lt;/p&gt;

&lt;p&gt;جالبی قضیه هم برام این بود که با کمترین زمان یه چیزی بنویسم، که کار کنه! و نوشتم. تو یک ساعت،‌کمتر از مدت زمانی که صرف انتخاب اسمش کردم نوشتمش&lt;a href=&#34;https://github.com/fzerorubigd/go0r&#34;&gt;go0r&lt;/a&gt;. اسمشم که مشخصه چرا این شد :) گور بدون مرده، گور صفر یا گور نال. ممنون از بچه‌های توییتر برای اسمش.&lt;/p&gt;

&lt;p&gt;خیلی ساده و در ۱۰۰ خط کد - که کاملا اتفاقی بود و وقتی تموم شد فهمیدم ۱۰۰ خط شده - اینکار رو انجام دادم، تازه از  &lt;a href=&#34;http://spf13.com/project/viper&#34;&gt;viper&lt;/a&gt; و &lt;a href=&#34;https://github.com/Sirupsen/logrus&#34;&gt;logrus&lt;/a&gt; هم استفاده کردم که برای یه کار کوچیک معمولا نیازی بهشون نیست ولی چون قصد دارم در آینده یه سری قابلیت دیگه هم اضافه کنم بهش، ازشون استفاده کردم.&lt;/p&gt;

&lt;p&gt;قصد داشتم هفته پیش این بلاگ رو استارت کنم که یه اتفاق فوق‌العاده بد برام افتاد، و خوب، به هرحال زندگی ادامه داره.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>